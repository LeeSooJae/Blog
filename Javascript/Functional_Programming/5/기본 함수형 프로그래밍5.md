# 함수형 프로그래밍 전문가 되기 (Part 5)

함수형 프로그래밍 컨셉들을 이해하는 첫 단계가 가장 중요하고 때로는 가장 어려운 단계다.
하지만 올바른 관점으로 접근한다면 그렇게 어렵지 않다.

이전 게시물 : Part 1, Part 2, Part 3, Part 4 

## 참조 무결성

참조 투명성은 순수함수가 표현식으로 대체될 수 있다고 설명하는 멋진 용어이다. 아래 예제가 이해하는데 도움이 될 것이다.

대수학에서 다음 공식을 봤을 때,

```js
y = x + 10
```

그리고 x 값이 다음과 같을 때

```js
x = 3
```

x값을 방정식에 대입하여 다음과 같은 식을 얻을 수 있다.

```js
y = 3 + 10
```

방정식이 아직 유효하다는 것에 주목해라. 우리는 순수함로도 위와 같은 대체를 할 수 있다.
 
여기 Elm로 작성한 문자열 주위에 작은 따옴표를 넣는 함수가 있다.
```js
quote str =
    "'" ++ str ++ "'"
```

그리고 위의 함수를 사용하는 코드를 살펴보자.

```js
findError key =
    "Unable to find " ++ (quote key)
```

*findError*는 *key*검색을 실패할때 오류 메시지를 생성한다.

*quote*함수가 순수하기 때문에, 우리는 간단히 함수를 *quote*함수의 본문 (')으로 대체 할 수 있다.

```js
findError key =
   "Unable to find " ++ ("'" ++ str ++ "'")
```  

이것을 나는 *Reverse Refactoring*이라고 부른다(그 편이 이해가 잘된다). 이 프로세스는 프로그래머 또는 프로그램이 코드를 추론하기 위해 사용할 수 있다. (예: 컴파일러 또는 테스트 프로그램)

이것은 특히 재귀함수에 대한 추론을 할때 도움이 된다.

## 실행 순서

대부분의 프로그램들은 싱글 스레드다. 즉 한 번에 하나의 코드만 실행 된다. 프로그램이 멀티스레드 일지라도 대부분의 스레드는 I/O 작업(파일, 네트워크 기타 등등)이 완료될 때 까지 차단된다.

이것이 우리가 코드를 작성할 때 순차적인 순서(ordered steps) 관점으로 생각하는 이유중 하나이다.

```
1. 빵을 꺼내라
2. 빵 2조각을 토스트 기계에 넣어라
3. 굽기를 선택해라
4. 레버를 밑으로 내려라
5. 토스트가 올라올때까지 기다려라
6. 토스트를 꺼내라
7. 버터를 꺼내라
8. 버터 칼을 꺼내라
9. 토스트에 버터를 발라라
```

이 예제에서 2가지 독립적인 동작이 있다. 버터를 꺼내는 것과, 빵을 굽는 것이다. 이들은 9단계가 되서야 상호의존적이 된다.

우리는 7, 8 단계와 1 ~ 6 단계를 동시에 진행 할 수 있다. 왜냐하면 서로에게 독립적인 행동들이기 때문이다.

하지만 위처럼 일을 하는 순간, 혼란에 빠진다.

```
Thread 1
--------
1. 빵을 꺼내라
2. 빵 2조각을 토스트 기계에 넣어라
3. 굽기를 선택해라
4. 레버를 밑으로 내려라
5. 토스트가 올라올때까지 기다려라
6. 토스트를 꺼내라

Thread 2
--------
1. 버터를 꺼내라
2. 버터 칼을 꺼내라
3. *Thread 1이 끝날때까지 기다려라*
4. 토스트에 버터를 발라라
```
 
만약 스레드 1이 실패 하면 스레드 2는 어떤 일이 발생 할까? 양 스레드들을 조율하는 메커니즘은 무엇인가? 누가 토스트의 주인인가? 스레드 1? 스레드 2? 아니면 둘다?

이러한 복잡성에 대해 생각하지 않고 우리의 프로그램을 단 하나의 스레드로 남겨두는 것이 더 쉽다.

그러나 프로그램의 효율을 가능한 최대로 짜낼 가치가 있을 때, 우리는 멀티스레딩 소프트웨어를 작성하는 것에 엄청난 노력을 기울여야 한다.

그러나 멀티 스레딩에는 2가지 주요한 문제 점이 있다. 첫번 째, 멀티 스레드 프로그램은 쓰기, 읽기, 추론, 테스트, 디버그가 어렵다. 

두번 째, 자바스크립트 같은 몇몇 언어들은 멀티스레딩을 지원하지 않는다. 지원 하더라도 좋지 않다.

그러나 순서 상관 없이 모든 것이 병렬로 처리되면 어떨까?

정신나간 소리로 들릴지도 모르지만, 그렇게 나쁜 방법은 아니다. 이를 이해하기 위해 Elm 코드를 살펴보자.

```js
buildMessage message value =
    let
        upperMessage =
            String.toUpper message
        quotedValue =
            "'" ++ value ++ "'"
    in
        upperMessage ++ ": " ++ quotedValue
```

*buildMessage*는 *message*와 *value*를 받은 뒤 대문자 *message*와 콜론(:), 그리고 작은 따옴표(')안의 *value*를 생산한다.

*upperMessage*와 *quotedValue*가 어떻게 독립적인지 주목해라. 어떻게 알 수 있을까?

독립적이기 위해서는 2가지가 true여야 한다. 첫 번째, 순수 함수여야 한다. 순수함수는 싱행될 때 서로의 실행에 영향을 끼치지 않기 때문에 중요하다.
두 번째, 한 함수의 출력 값이 다른 함수의 입력 값이 되면 안된다. 만약 이와 같은 상황이 일어난다면, 우리는 첫번째 스레드가 끝날 때까지 두번째 스레드를 실행 시키지 못하고 기다려야 한다.

위의 코드에서 *upperMessage*와 *quotedValue*는 둘다 순수 함수고, 다른 하나의 출력 값을 필요로 하지 않는다.

그러므로 이 두 함수는 *순서에 상관없이* 실행이 잘 된다.  

컴파일러는 프로그래머의 도움없이 알아서 결정 할 수 있다. 이것은 부작용의 영향을 파악하는 것이 어렵기 때문에 순수 함수 언어에서만 가능하다.

> 순수 함수 언어의 실행 순서는 컴파일러에 의해 결정된다.

현재 CPU 속도가 빨라지지 않고 있는 것을 보면 이 것은 굉장한 이점이 있다. CPU 속도가 빨라지지 않는 대신에 코어수가 점점 더 증가하고 있다. 이는 하드웨어 레벨에서 코드가 병렬로 실행될 수 있다는 것을 뜻한다.

불행하게도, 명령형 언어에서는 매우 거친 수준을 제외하고 이러한 코어의 장점을 완전히 활용할 수 없다. 완전히 활용하려면 프로그램의 구조를 획기적으로 바꿔야 한다.

순수 함수형 언어를 사용하면 코드 한줄을 변경하지 않고도 미세한 레벨의 CPU 코어를 자동으로 활용할 수 있다. 

## 타입 명시

전적 타입 언어에서, 타입이 인라인(inline)으로 정의된다. 이해 하기 위해 아래의 Java 코드를 살펴보자.

```java
public static String quote(String str) {
    return "'" + str + "'";
}
```

함수 정의와 함께 타입이 어떻게 인라인이 되는지 주목해라. 제네릭을 사용한다면 더 나빠질 것이다.

```java
private final Map<Integer, String> getPerson(Map<String, String> people, Integer personId) {
   // ...
}
```
나는 그것들을 돋보이게 하는 타입들을 대담하게 표현했지만, 그것들은 여전히 기능 정의에 방해가 된다. 변수의 이름을 찾으려면 주의 깊게 읽어야 한다.

동적 타입 언어에서 이것은 문제가 되지 않는다. 자바스크립트에서 코드를 다음과 같이 작성 할 수 있다.
```js
var getPerson = function(people, personId) {
    // ...
};
```

타입의 정보가 없는 것이 문제가 되지 않는다면 읽기 더 쉬워진다. 단 하나의 문제는 타입 안전성을 포기한 것이다. 우리는 쉽게 이 파라미터들을 거꾸로 전달할 수도 있다. 즉, people을 숫자타입으로, personId를 객체타입으로 전달할 수 있다.   
